<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link href="./assets/css/xua-documentation.css" rel="stylesheet" type="text/css" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         processEscapes: true
        }
      });
    </script>

    <title>Supers; - Xua Documentation</title>
</head>

<body>

    <div id="page">

        <div id="header">
            <div class='booktitleinheader'><a href='./index.html'>Xua Documentation</a></div>
            <ul id='menu'>
                <li class='menu-item'><a href='./TableOfContents.html'>Table of Contents</a></li>
                <li class='menu-item'><a href='./CheatSheet.html'>Cheat Sheet</a></li>
                <li class='menu-item'><a href='./Architecture.html'>Architecture</a></li>
                <li class='menu-item'><a href='./HandBook.html'>Hand Book</a></li>
            </ul>
        </div>

        <div id="main">

            <h1 class="libtitle">
                Supers;
                <span class="subtitle">A Whole Level Beyond Types</span>
            </h1>

            <div class = 'comment'><a href='#Introduction'><h2 class='heading h2' id='Introduction'> Introduction</h2></a>
Super types or simply supers are parametric types. Read <a href='Units.html#Super_Types'>Super Types</a> section under <a href='Units.html'>Units</a> chapter for theoretical explanations. In this chapter, we focus on practical details of defining and using supers.</div><div class = 'comment'><a href='#Effects_on_the_projects'><h3 class='heading h3' id='Effects_on_the_projects'> Effects on the projects</h3></a>
Each super results in a PHP class in the Server project, extending the abstract class <code>Super</code> or another Super.</div><div class = 'comment'>Also, the same happens in the Marshal library with respect to the language. However, the front-end clone of the super does not contain the predicate and is only accessible in the MUU (Marshal/Unmarshal Unit).</div><div class = 'comment'><a href='#Terminology'><h3 class='heading h3' id='Terminology'> Terminology</h3></a>
Assume $A$ is a set, the predicate $P$ is called characteristic predicate of $A$ if $P(x) \iff x \in A$. We can use set $A$ and predicate $P$ alternatively since they both carry the same concept.</div><div class = 'comment'>A type is a set occupied with functions $M$, $U$, and $T$. Read <a href='Units.html#Super_Types'>Super Types</a> section under <a href='Units.html'>Units</a> chapter to see what these objects are. We usually show a type set by its characteristic predicate instead of the set itself.</div><div class = 'comment'>Assume $T = (P, Y, M, U)$. We say type $T$ explicitly accepts value $x$ if $P(x)$ is true, and say type $T$ implicitly accepts value $x$, if $P(x)$ is true or $P(U(x))$ is true. If type $T$ explicitly (implicitly) accepts $x$, we say $x$ explicitly (implicitly) fits in $T$. As a convention, when we say $T$ accept $x$, we mean $T$ implicitly accepts $x$, and the same is true for fitting.</div><div class = 'comment'>A Super Type or simply Super is a function that receives some arguments and returns a type. This type is called an instance of the Super Type.</div><div class = 'comment'><a href='#Definition'><h2 class='heading h2' id='Definition'> Definition</h2></a></div><div class = 'comment'><a href='#Structure'><h3 class='heading h3' id='Structure'> Structure</h3></a>
A super block definition has the following structure.</div><pre><code>#&nbsp;Path\To\Super\SuperName<br>&nbsp;<br>#&nbsp;Description&nbsp;of&nbsp;this&nbsp;Super,&nbsp;probably&nbsp;in&nbsp;markdown&nbsp;formatting<br>&nbsp;<br>Super&nbsp;[extends&nbsp;Path\To\Another\Super\SuperName]&nbsp;{<br>&nbsp;&nbsp;[arguments&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;[const]&nbsp;argName0&nbsp;:&nbsp;Type0&nbsp;[=&nbsp;DEFAULT_0];&nbsp;#&nbsp;Description&nbsp;of&nbsp;argName0<br>&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;#&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;[const]&nbsp;argNameN&nbsp;:&nbsp;TypeN&nbsp;[=&nbsp;DEFAULT_N];&nbsp;#&nbsp;Description&nbsp;of&nbsp;argNameN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;}]<br>&nbsp;&nbsp;[&nbsp;validation&nbsp;{&nbsp;VALIDATION_BODY&nbsp;}&nbsp;]<br>&nbsp;&nbsp;predicate&nbsp;{&nbsp;PREDICATE_BODY&nbsp;}<br>&nbsp;&nbsp;[&nbsp;type&lt;TARGET_0&gt;&nbsp;{&nbsp;TYPE_0_BODY&nbsp;}&nbsp;]<br>&nbsp;&nbsp;[&nbsp;marshal&lt;TARGET_0&gt;&nbsp;{&nbsp;MARSHAL_0_BODY&nbsp;}&nbsp;]<br>&nbsp;&nbsp;[&nbsp;unmarshal&lt;TARGET_0&gt;&nbsp;{&nbsp;UNMARSHAL_0_BODY&nbsp;}&nbsp;]<br>&nbsp;&nbsp;...<br>&nbsp;&nbsp;[&nbsp;type&lt;TARGET_N&gt;&nbsp;{&nbsp;TYPE_N_BODY&nbsp;}&nbsp;]<br>&nbsp;&nbsp;[&nbsp;marshal&lt;TARGET_N&gt;&nbsp;{&nbsp;MARSHAL_N_BODY&nbsp;}&nbsp;]<br>&nbsp;&nbsp;[&nbsp;unmarshal&lt;TARGET_N&gt;&nbsp;{&nbsp;UNMARSHAL_N_BODY&nbsp;}&nbsp;]<br>}<br></code></pre><div class = 'comment'>Note that there is no name for the Super. A Super name is its file path. Each file can contain at most one block, and the block inherits its name from the file. It is a good practice to have a comment in the first line of the file describing where the file is located.</div><div class = 'comment'><a href='#Arguments'><h3 class='heading h3' id='Arguments'> Arguments</h3></a>
It is possible to define a set of arguments for a Super. The resulting type is based on those arguments. For each argument, it is possible to set a default value, and it is mandatory to set a type. However, the only way to mention a type is to call a super that returns a type, and we need types to define supers. So how to define the first Super? The answer is we do not <em>NEED</em> types to define a super since we do not need the super to have any argument. This fact leads us to the very first Super, called <code>Universal</code>.</div><div class = 'comment'>It is possible to define some arguments as constant, which means the programmer cannot pass that argument to the Super. This feature is useful when defining a child super. Read more in <a href='#Hierarchy'>Hierarchy</a>.</div><pre><code>#&nbsp;\Xua\Supers\Universal<br>Super&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Predicate&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre><div class = 'comment'>After this, we may use the <code>Universal</code> Super to define other Supers. Although, we may define other Supers without using arguments, such as <code>Boolean</code> and <code>Trilean</code>.</div><div class = 'comment'><a href='#Validation'><h3 class='heading h3' id='Validation'> Validation</h3></a>
The <code>validation</code> block is responsible for checking if arguments passed to the Super meet desired conditions. It is an optional Block, and if it is not provided, any argument that fits in the corresponding type will be accepted.</div><div class = 'comment'>The body is written in pure PHP. All super arguments are available as PHP variables
<code>$this-&gt;argName0</code>, ...,
<code>$this-&gt;argNameN</code>,
There is also another available variable
<code>$exception</code>,
which has a method called <code>setError</code>, and one can use it to add an error if some wanted conditions are not met.</div><div class = 'comment'><a href='#Predicate'><h3 class='heading h3' id='Predicate'> Predicate</h3></a>
The <code>Predicate</code> is the main and only required block of a super. This block defines the characteristic predicate.</div><div class = 'comment'>The body is written in pure PHP. All super arguments are available as PHP variables
<code>$this-&gt;argName0</code>, ...,
<code>$this-&gt;argNameN</code>,
along with two extra variables
<code>$input</code>
and
<code>$message</code>.
The variable
<code>$input</code>
contains the value which the predicate should check. The value <code>true</code> must be returned if
<code>$input</code>
explicitly fits in the type, and <code>false</code> otherwise.</div><div class = 'comment'>When returning <code>false</code>, it is possible to provide a reason of why
<code>$input</code>
failed to fit in the type. The
<code>$message</code>
variable is responsible for storing this reason.</div><div class = 'comment'><a href='#Marshal_&_Unmarshal'><h3 class='heading h3' id='Marshal_&_Unmarshal'> Marshal & Unmarshal</h3></a>
Blocks <code>Marshal</code> and <code>Unmarshal</code> can be written for any supported language. Therefore these block names are valid: <code>marshal&lt;php&gt;</code>, <code>marshal&lt;database&gt;</code>, <code>marshal&lt;dart&gt;</code>, <code>marshal&lt;php&gt;</code>, <code>marshal&lt;java&gt;</code>, <code>marshal&lt;javascript&gt;</code>, <code>marshal&lt;kotlin&gt;</code>, <code>marshal&lt;objectivec&gt;</code>, and <code>marshal&lt;swift&gt;</code>. The body of <code>database</code> blocks, is written in PHP, but the methods are used for database store and restore procedures.</div><div class = 'comment'>Any unwritten block is assumed to be the identity function.</div><div class = 'comment'>The function of the <code>marshal</code> block is to cast a given value into a value that can be transmitted on the network or stored in the database (usually string, integer, or a stream of bytes) in an invertible way. The <code>unmarshal</code> does the inverse of the <code>marshal</code> function.</div><div class = 'comment'>When the language is PHP (target is <code>php</code> or <code>database</code>), all Super arguments are available as PHP variables
<code>$this-&gt;argName0</code>,
...,
<code>$this-&gt;argNameN</code>,
along with an extra variable
<code>$input</code>,
and the marshaled/unmarshaled data must be returned. When calling <code>Marshal</code>, it is guaranteed that
<code>$input</code>
explicitly fits in the type. But when calling <code>unmarshal</code>, it is possible that
<code>$input</code>
is not a valid input; in that case, the convention is to return the input value itself.</div><div class = 'comment'>For other languages, the same concept holds with respect to the language syntax.</div><div class = 'comment'><a href='#Native_Type'><h3 class='heading h3' id='Native_Type'> Native Type</h3></a>
There are some scenarios where we need to declare a type (the result of calling a Super) in another language. For example, if we use a type as the type of an Entity field, we must tell the database server to store the values. This declaration is the job of the <code>Type</code> block. All super arguments are available as PHP variables
<code>$this-&gt;argName0</code>,
...,
<code>$this-&gt;argNameN</code>.
And the block must either return a string identifying the database type (for example, <code>VARCHAR(100)</code>) or <code>null</code> value, which means the type is not available in the specified target. If the block is not provided, the <code>null</code> return value is assumed.</div><div class = 'comment'><a href='#Hierarchy'><h3 class='heading h3' id='Hierarchy'> Hierarchy</h3></a>
Supers can come in a hierarchy just like PHP classes, and each block is a class method. It is possible to call the parent method in the child method since the block's content is written in PHP. It is also possible to call parent methods in non-PHP blocks with respect to the language syntax.</div><div class = 'comment'>To do so, it is mandatory to know the name of the class method generated by each block. Here is a list of blocks with corresponding methods.</div><pre><code>#&nbsp;PHP&nbsp;Blocks<br>Validation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_validation(SuperValidationException&nbsp;$exception)<br>Predicate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_predicate($input,&nbsp;string&nbsp;&amp;$message)<br>Marshal&lt;database&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_marshalDatabase($input)<br>Unmarshal&lt;database&gt;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_unmarshalDatabase($input)<br>Marshal&lt;php&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_marshal($input)<br>Unmarshal&lt;php&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_unmarshal($input)<br>Type&lt;database&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_databaseType()<br>Type&lt;php&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_phpType()<br>#&nbsp;non-PHP&nbsp;Blocks<br>Marshal&lt;FRONT_LANG&gt;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_marshal($input)<br>Unmarshal&lt;FRONT_LANG&gt;&nbsp;=&gt;&nbsp;protected&nbsp;_unmarshal($input)<br>Type&lt;FRONT_LANG&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;protected&nbsp;_type()<br></code></pre><div class = 'comment'>So for example if one needs to call parent predicate in php, they may write <code>parent::predicate($input)</code>.</div><div class = 'comment'>Also, the arguments of child super override the ones in the parent. This override includes type, default value, and being constant. It is also possible to add new arguments to the type. Read <a href='#Examples'>Examples</a> for more details.</div><div class = 'comment'><a href='#Visibility'><h3 class='heading h3' id='Visibility'> Visibility</h3></a>
The visibility of supers is controlled via the Marshal and Unmarshal blocks. Although the supers are never accessible in the front-end project, the Marshal library can use these methods to send and receive values of a type. However, if the methods are not available, this means that we do not want the Marshal library to be able to use them.</div><div class = 'comment'>By the way, there is usually no point in controlling Super's visibility.</div><div class = 'comment'><a href='#Usage'><h2 class='heading h2' id='Usage'> Usage</h2></a>
It is possible to use a defined super in both PHP and Xua languages, but not in Marshal library.</div><div class = 'comment'><a href='#Inside_PHP'><h3 class='heading h3' id='Inside_PHP'> Inside PHP</h3></a>
Although it is not usually helpful to work with supers inside PHP codes, it is possible.</div><div class = 'comment'><a href='#Make_a_type'><h4 class='heading h4' id='Make_a_type'> Make a type</h4></a>
The following code makes a type by giving arguments to a super.</div><pre><code>$type&nbsp;=&nbsp;new&nbsp;Path\To\Super\SuperName([<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;argName0&#x27;&nbsp;=&gt;&nbsp;$value0,<br>&nbsp;&nbsp;&nbsp;&nbsp;...,<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;argNameN&#x27;&nbsp;=&gt;&nbsp;$valueN,<br>]);<br></code></pre><div class = 'comment'><a href='#Determine_a_type'><h4 class='heading h4' id='Determine_a_type'> Determine a type</h4></a>
Assume a type is given in a variable and we need to know what type is it. We can try to find the class of the object but what about arguments? The <code>parameters</code> method returns the array that was given to the Super at first place, and the <code>toString</code> method returns a string that describes the type.</div><pre><code>var_dump(get_class($type));<br>var_dump($type-&gt;parameters());<br>var_dump($type-&gt;toString());<br></code></pre><div class = 'comment'>This code dumps the following.</div><pre><code>string&nbsp;&quot;Path\To\Super\SuperName&quot;<br>[<br>&nbsp;&nbsp;&nbsp;&nbsp;argName0&nbsp;=&gt;&nbsp;value0,<br>&nbsp;&nbsp;&nbsp;&nbsp;...,<br>&nbsp;&nbsp;&nbsp;&nbsp;argNameN&nbsp;=&gt;&nbsp;valueN<br>]<br>string&nbsp;&quot;Path\To\Super\SuperName(argName0&nbsp;=&nbsp;value0,&nbsp;...,&nbsp;argNameN&nbsp;=&nbsp;valueN)&quot;<br></code></pre><div class = 'comment'><a href='#Accepts,_Implicit_&_Explicit'><h4 class='heading h4' id='Accepts,_Implicit_&_Explicit'> Accepts, Implicit & Explicit</h4></a>
There are three <code>accepts</code> functions defined on a type.</div><div class = 'comment'><a href='#explicitlyAccepts'><h5 class='heading h5' id='explicitlyAccepts'> explicitlyAccepts</h5></a>
This function will return true only if the value explicitly fits in the type. The second argument is optional, and if the return value is false, the function may fill it with a reason.</div><pre><code>if&nbsp;($type-&gt;explicitlyAccepts($value,&nbsp;$reason))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;var_dump($value);<br>&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#x27;is&nbsp;of&nbsp;type&nbsp;&#x27;&nbsp;.&nbsp;$type-&gt;toString();<br>}&nbsp;else&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#x27;Rejected,&nbsp;because:&#x27;&nbsp;.&nbsp;$reason;<br>}<br></code></pre><div class = 'comment'><a href='#implicitlyAaccepts'><h5 class='heading h5' id='implicitlyAaccepts'> implicitlyAaccepts</h5></a>
This function will return true if the value explicitly fits in the type, or fits after unmarshaling. The unmarshaling methods must be determined by the caller. The function tries the value itself first, then tries to unmarshal and check if the value fits by given methods, one by one. If not passed to the function, the default value <code>[self::METHOD&lt;em&gt;IDENTITY, self::METHOD&lt;/em&gt;UNMARSHAL, self::METHOD&lt;em&gt;UNMARSHAL&lt;/em&gt;DATABASE]</code> is assumed.</div><pre><code>if&nbsp;($type-&gt;implicitlyAccepts($value,&nbsp;$reasons,&nbsp;[self::METHOD_IDENTITY,&nbsp;self::METHOD_UNMARSHAL<br>]))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;var_dump($value);<br>&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#x27;kinda&nbsp;fits&nbsp;in&nbsp;the&nbsp;type&nbsp;&#x27;&nbsp;.&nbsp;$type-&gt;toString();<br>}&nbsp;else&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#x27;fully&nbsp;rejected&nbsp;because&nbsp;of&nbsp;the&nbsp;following&nbsp;reasons&#x27;;<br>&nbsp;&nbsp;&nbsp;&nbsp;var_dump($reasons);<br>}<br></code></pre><div class = 'comment'><a href='#accepts'><h5 class='heading h5' id='accepts'> accepts</h5></a>
This function does the same job of <code>implicitlyAccepts</code>, but may alter the original value while trying to fit it in the type.</div><pre><code>$originalValue&nbsp;=&nbsp;$value;<br>if&nbsp;($type-&gt;accepts($value,&nbsp;$reasons,&nbsp;[self::METHOD_IDENTITY,&nbsp;self::METHOD_UNMARSHAL<br>]))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;var_dump($originalValue);<br>&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#x27;was&nbsp;changed&nbsp;to&#x27;;<br>&nbsp;&nbsp;&nbsp;&nbsp;var_dump($value);<br>&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#x27;to&nbsp;fit&nbsp;in&nbsp;type&nbsp;&#x27;&nbsp;.&nbsp;$type-&gt;toString();<br>}&nbsp;else&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&#x27;fully&nbsp;rejected&nbsp;because&nbsp;of&nbsp;the&nbsp;following&nbsp;reasons&#x27;;<br>&nbsp;&nbsp;&nbsp;&nbsp;var_dump($reasons);<br>}<br></code></pre><div class = 'comment'><a href='#Marshal_&_Unmarshal'><h4 class='heading h4' id='Marshal_&_Unmarshal'> Marshal & Unmarshal</h4></a>
There are two types of marshal and unmarshal functions available in the server project.</div><div class = 'comment'><a href='#Network_transmissions'><h5 class='heading h5' id='Network_transmissions'> Network transmissions</h5></a>
Functions <code>marshal</code> and <code>unmarshal</code> are responsible to marshal and unmarshal values for purpose of network transmissions.</div><pre><code>$marshaledValue&nbsp;=&nbsp;$type-&gt;marshal($value);<br>$originalValue&nbsp;=&nbsp;$type-&gt;unmarshal($marshaledValue);<br>if&nbsp;($value&nbsp;!==&nbsp;$originalValue)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;var_dump(&#x27;something&nbsp;is&nbsp;wrong&nbsp;with&nbsp;marshal/unmarshal&nbsp;functions&nbsp;of&nbsp;&#x27;&nbsp;.&nbsp;$type-&gt;toString());<br>}<br></code></pre><div class = 'comment'><a href='#Database_Storing_&_Restoring'><h5 class='heading h5' id='Database_Storing_&_Restoring'> Database Storing & Restoring</h5></a>
Functions <code>marshalDatabase</code> and <code>unmarshalDatabase</code> are responsible to marshal and unmarshal values for purpose of storing and restoring into/from database.</div><pre><code>$marshaledValue&nbsp;=&nbsp;$type-&gt;marshalDatabase($value);<br>$originalValue&nbsp;=&nbsp;$type-&gt;unmarshalDatabase($marshaledValue);<br>if&nbsp;($value&nbsp;!==&nbsp;$originalValue)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;var_dump(&#x27;something&nbsp;is&nbsp;wrong&nbsp;with&nbsp;marshalDatabase/unmarshalDatabase&nbsp;functions&nbsp;of&nbsp;&#x27;&nbsp;.&nbsp;$type-&gt;toString());<br>}<br></code></pre><div class = 'comment'><a href='#Native_Type'><h4 class='heading h4' id='Native_Type'> Native Type</h4></a>
The functions <code>phpType</code> <code>databaseType</code> have no arguments and return a string that declares the type in PHP and database engine syntax. <code>phpType</code> is mostly used in PHPDocs to declare the classes properties type, while <code>databaseType</code> is mostly used to tell the database server how the type values must be stored. These functions are hardly helpful in programming.</div><div class = 'comment'><a href='#Inside_Xua'><h3 class='heading h3' id='Inside_Xua'> Inside Xua</h3></a>
The main usage of Supers is to declare types for Xua Super arguments, Entity fields, and Method request and response signatures (and Method field signatures for VARQUE Methods). To mention a type, one must call a Super and give it arguments. The type then can be used for type declaration. The syntax is the following.</div><pre><code>Path\To\Super\SuperName(<br>&nbsp;&nbsp;&nbsp;&nbsp;argName0&nbsp;=&nbsp;constant0,<br>&nbsp;&nbsp;&nbsp;&nbsp;...,<br>&nbsp;&nbsp;&nbsp;&nbsp;argNameN&nbsp;=&nbsp;constantN,<br>)<br></code></pre><div class = 'comment'><a href='#Examples'><h2 class='heading h2' id='Examples'> Examples</h2></a></div><div class = 'comment'><a href='#Range'><h3 class='heading h3' id='Range'> Range</h3></a>
In this section, we want to work with a Super that accepts the range of integers in $[a, b)$.</div><div class = 'comment'><a href='#Definition'><h4 class='heading h4' id='Definition'> Definition</h4></a>
First of all, we need to define the Super. We put it in the file <code>Supers/Integers/Range.xua</code>.</div><div class = 'comment'><a href='#Extension'><h5 class='heading h5' id='Extension'> Extension</h5></a>
A value of this type needs to be an integer so we can reuse marshal, unmarshal, and native type methods of the <code>Integer</code> Super, and also the predicate of that Super would be useful to check if the value is an integer. So it seems like a good idea to extend the Super <code>Integer</code>.</div><pre><code>Super&nbsp;extends&nbsp;Integer<br></code></pre><div class = 'comment'><a href='#Arguments'><h5 class='heading h5' id='Arguments'> Arguments</h5></a>
We need to have two arguments determining the start and end of the range. The arguments must be integer themselves.</div><pre><code>#&nbsp;Supers\Integers\Range<br>Super&nbsp;extends&nbsp;Integer&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;arguments&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;:&nbsp;Integer();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;&nbsp;&nbsp;:&nbsp;Integer();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;validation&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;TODO&nbsp;implement<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;predicate&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;TODO&nbsp;implement<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre><div class = 'comment'><a href='#Validation'><h5 class='heading h5' id='Validation'> Validation</h5></a>
For the validation, we must check that the second number is not less than the first one. Note that we do not need to check if the type of arguments is integer since we already declared their type so the type checking is automatically done.</div><pre><code>validation&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($this-&gt;end&nbsp;&lt;&nbsp;$this-&gt;start)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$exception-&gt;setError(&#x27;end&#x27;,&nbsp;&#x27;The&nbsp;argument&nbsp;`end`&nbsp;cannot&nbsp;be&nbsp;less&nbsp;than&nbsp;the&nbsp;argument&nbsp;`start`.&#x27;);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre><div class = 'comment'><a href='#Predicate'><h5 class='heading h5' id='Predicate'> Predicate</h5></a>
We can just simply check if the <code>$input</code> is an Integer and is in the range.</div><pre><code>Predicate&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;parent::_predicate($input)&nbsp;and&nbsp;$this-&gt;start&nbsp;&lt;=&nbsp;$input&nbsp;and&nbsp;$input&nbsp;&lt;&nbsp;$this-&gt;end;<br>}<br></code></pre><div class = 'comment'>But we can make it a little more sophisticated by providing a reason of why the value may fail to fit.</div><pre><code>Predicate&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!parent::_validation($input,&nbsp;$message))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;message&nbsp;is&nbsp;already&nbsp;filled&nbsp;here&nbsp;by&nbsp;the&nbsp;parent&nbsp;_validation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($input&nbsp;&lt;&nbsp;$this-&gt;start)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$message&nbsp;=&nbsp;$input&nbsp;.&nbsp;&#x27;&nbsp;is&nbsp;less&nbsp;than&nbsp;&#x27;&nbsp;.&nbsp;$this-&gt;start;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($input&nbsp;&gt;=&nbsp;$this-&gt;end)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$message&nbsp;=&nbsp;$input&nbsp;.&nbsp;&#x27;&nbsp;is&nbsp;not&nbsp;less&nbsp;than&nbsp;&#x27;&nbsp;.&nbsp;$this-&gt;end;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>}<br></code></pre><div class = 'comment'>Note that it is OK to fill the $message when the return value is <code>true</code>. Xua automatically clears the <code>$message</code> in that case.</div><div class = 'comment'><a href='#Marshal_and_Unmarshal'><h5 class='heading h5' id='Marshal_and_Unmarshal'> Marshal and Unmarshal</h5></a>
The defined Super is ready-to-go with no further modifications; since the <code>Integer</code> Super includes the desired Marshal and Unmarshal functions and <code>Range</code> inherits them. However, for the purpose of this documentation, we override them with a new network transmit marshaling system.</div><div class = 'comment'>The silly idea is to shift starting number to zero to have smaller integers which are easier to transmit (practically useless). For example The range $[1000, 1100)$ can be shifted to $[0, 100)$.</div><pre><code>Marshal&lt;php&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$input&nbsp;-&nbsp;$this-&gt;start;<br>}<br>Unmarshal&lt;php&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$input&nbsp;+&nbsp;$this-&gt;start;<br>}<br>Marshal&lt;javascript&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;input&nbsp;-&nbsp;this.args.start;<br>}<br>Unmarshal&lt;javascript&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;input&nbsp;+&nbsp;this.args.start;<br>}<br></code></pre><div class = 'comment'><a href='#Native_Type'><h5 class='heading h5' id='Native_Type'> Native Type</h5></a>
The PHP type is inherited and returns <code>int</code>, which is great. However, the database type is an interesting part of the definition since we can determine the length of MySQL <code>INT</code> by the range limits.</div><div class = 'comment'>We know that <code>INT(n)</code> can store values in range $[-2^{n-1}, 2^{n-1}]$. So it is efficient to find the least $n$ such that this range contains our range. First, we find the maximum absolute value that can fit in the type.</div><pre><code>$min&nbsp;=&nbsp;$this-&gt;start;<br>$max&nbsp;=&nbsp;$this-&gt;end&nbsp;-&nbsp;1;<br>$absMax&nbsp;=&nbsp;max(abs($min),&nbsp;abs($max));<br></code></pre><div class = 'comment'>Let us say this number is $M$. we must find $n$ such that $M \leq 2^{n-1}$.
$$\begin{eqnarray}
M \leq 2^{n-1} & \iff & \log_2(M) \leq n - 1 \\
(\text{Since $n - 1$ is integer}) & \iff & \lceil \log_2(M) \rceil \leq n - 1 \\
& \iff & \lceil \log_2(M) \rceil + 1 \leq n \\
\end{eqnarray}$$</div><div class = 'comment'>So the minimum value of $n$ is $\lceil \log_2(M) \rceil + 1$.</div><pre><code>$n&nbsp;=&nbsp;ceil(log($absMax,&nbsp;2))&nbsp;+&nbsp;1;<br></code></pre><div class = 'comment'>This leads us to the following database type.</div><pre><code>type&lt;database&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;$min&nbsp;=&nbsp;$this-&gt;start;<br>&nbsp;&nbsp;&nbsp;&nbsp;$max&nbsp;=&nbsp;$this-&gt;end&nbsp;-&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;$absMax&nbsp;=&nbsp;max(abs($min),&nbsp;abs($max));<br>&nbsp;&nbsp;&nbsp;&nbsp;$n&nbsp;=&nbsp;ceil(log($absMax,&nbsp;2))&nbsp;+&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;INT($n)&quot;;<br>}<br></code></pre><div class = 'comment'><a href='#Further_Hierarchy'><h5 class='heading h5' id='Further_Hierarchy'> Further Hierarchy</h5></a></div><div class = 'comment'><a href='#Validation'><h6 class='heading h6' id='Validation'> Validation</h6></a>
Assume that we want another Super with the same features, but only for positive values. We can extend again what we already have.</div><pre><code>#&nbsp;Supers\Integers\PositiveRange<br>Super&nbsp;extends&nbsp;Range&nbsp;()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;validation&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent::validation();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($this-&gt;start&lt;=&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$exception-&gt;setError(&#x27;start&#x27;,&nbsp;&#x27;The&nbsp;range&nbsp;must&nbsp;be&nbsp;positive.&#x27;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre><div class = 'comment'><a href='#Constant_Arguments'><h6 class='heading h6' id='Constant_Arguments'> Constant Arguments</h6></a>
Or assume we want a range super that can only start at zero.</div><pre><code>#&nbsp;Supers\Integers\NaturalUpperLimit<br>Super&nbsp;extends&nbsp;Range&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;arguments&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;start&nbsp;:&nbsp;Integer()&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre><div class = 'comment'>Note the way we overrode the <code>start</code> with default value, but also set it constant so the caller cannot change it.</div><pre><code>$type&nbsp;=&nbsp;new&nbsp;NaturalUpperLimit([&#x27;start&#x27;&nbsp;=&gt;&nbsp;1,&nbsp;&#x27;end&#x27;&nbsp;=&gt;&nbsp;2]);<br></code></pre><div class = 'comment'>This code will result in an uncaught <code>SuperValidationException</code>.</div><div class = 'comment'><a href='#Marshaling'><h6 class='heading h6' id='Marshaling'> Marshaling</h6></a>
But better than these, assume we use the network transmit marshaling procedures for the database, which actually impacts the table size. Furthermore, we can remove the silly network transmit marshaling procedure. Also, note that we must override the <code>type&lt;database&gt;</code> as well.</div><pre><code>#&nbsp;Supers\Integers\EfficientRange<br>Super&nbsp;extends&nbsp;Range&nbsp;()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Marshal&lt;php&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$input;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;Unmarshal&lt;php&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$input;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;Marshal&lt;javascript&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$input;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;Unmarshal&lt;javascript&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$input;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;Marshal&lt;database&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$input&nbsp;-&nbsp;$this-&gt;start;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;Unmarshal&lt;database&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$input&nbsp;+&nbsp;$this-&gt;start;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;DatabaseType&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$max&nbsp;=&nbsp;$this-&gt;end&nbsp;-&nbsp;$this-&gt;start&nbsp;-&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$n&nbsp;=&nbsp;ceil(log($max,&nbsp;2))&nbsp;+&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;INT($n)&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre><div class = 'comment'><a href='#New_Arguments'><h6 class='heading h6' id='New_Arguments'> New Arguments</h6></a>
Another example is when we want to add arguments to a Super. For example, assume we want a <code>step</code> argument. By default, the step is one, but if we set the <code>step</code> to three, the type accepts <code>start</code> and every third number.</div><pre><code>#&nbsp;Supers\Integers\StepRange<br>Super&nbsp;extends&nbsp;Range&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;arguments&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step&nbsp;:&nbsp;Integer()&nbsp;=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;validation&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent::validation();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(step&nbsp;&lt;&nbsp;1)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$exception-&gt;setError(&#x27;step&#x27;,&nbsp;&#x27;The&nbsp;step&nbsp;must&nbsp;be&nbsp;at&nbsp;least&nbsp;1.&#x27;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;predicate&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!parent::predicate($input,&nbsp;$message))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($input&nbsp;-&nbsp;$this-&gt;argument[&#x27;start&#x27;]&nbsp;%&nbsp;$this-&gt;argument[&#x27;step&#x27;]&nbsp;!=&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$message&nbsp;=&nbsp;&quot;value&nbsp;{$input}&nbsp;minus&nbsp;starting&nbsp;point&nbsp;{$this-&gt;argument[&#x27;start&#x27;]}&nbsp;is&nbsp;not&nbsp;devisable&nbsp;by&nbsp;step&nbsp;value&nbsp;{$this-&gt;argument[&#x27;step&#x27;]}.&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre><div class = 'comment'><a href='#Usage'><h4 class='heading h4' id='Usage'> Usage</h4></a>
After defining a super, we can use it to define types and use them.</div><div class = 'comment'><a href='#Inside_PHP'><h5 class='heading h5' id='Inside_PHP'> Inside PHP</h5></a>
First, Let us define a type that accepts the range $[10, 30)$. We use the <code>EfficientRange</code>.</div><pre><code>$type&nbsp;=&nbsp;new&nbsp;EfficientRange([&#x27;start&#x27;&nbsp;=&gt;&nbsp;10,&nbsp;&#x27;end&#x27;&nbsp;=&gt;&nbsp;30]);<br></code></pre><div class = 'comment'>Let us see how Xua stringifies this type.</div><pre><code>var_dump($type-&gt;toString());<br></code></pre><div class = 'comment'>This code dumps <code>Supers\Integers\EfficientRange(start = 10, end = 30)</code>.</div><div class = 'comment'>The value <code>25</code> explicitly fits in the type, while the value <code>5</code> implicitly fits.</div><pre><code>$value&nbsp;=&nbsp;25;<br>var_dump($type-&gt;explicitlyAccepts($value));&nbsp;#&nbsp;dumps&nbsp;true<br>$value&nbsp;=&nbsp;5;<br>var_dump($type-&gt;implicitlyAccepts($value));&nbsp;#&nbsp;dumps&nbsp;true<br></code></pre><div class = 'comment'>Of course the value <code>25</code> also fits in the type implicitly. This is because the function first checks if the value explicitly fits.</div><pre><code>$value&nbsp;=&nbsp;25;<br>var_dump($type-&gt;implicitlyAccepts($value));&nbsp;#&nbsp;dumps&nbsp;true<br></code></pre><div class = 'comment'>We know that value <code>15</code> is ambiguous. It can be interpreted as <code>15</code> itself, a value in range, or the result of marshaling <code>25</code>. Let us call accept and check the result.</div><pre><code>$value&nbsp;=&nbsp;15;<br>var_dump($type-&gt;accepts($value));&nbsp;#&nbsp;dumps&nbsp;true<br>var_dump($value);&nbsp;#&nbsp;dumps&nbsp;15<br></code></pre><div class = 'comment'>Since the function first tries the explicit, if the value fits explicitly, function does not change the value. What about <code>5</code> that can only fit implicitly?</div><pre><code>$value&nbsp;=&nbsp;5;<br>var_dump($type-&gt;accepts($value));&nbsp;#&nbsp;dumps&nbsp;true<br>var_dump($value);&nbsp;#&nbsp;dumps&nbsp;15<br></code></pre><div class = 'comment'>This time the function tries to fit the value explicitly and fails, so it goes for unamrshaling, which leads to accept.</div><div class = 'comment'>We know the value $5$ does not fit explicitly, but we may wonder why. (It is super obvious but is a good way to see how to get the reason from the function.)</div><pre><code>$value&nbsp;=&nbsp;5;<br>var_dump($type-&gt;explicitlyAccepts($value,&nbsp;$reason));&nbsp;#&nbsp;dumps&nbsp;false<br>var_dump($reason);&nbsp;#&nbsp;dumps&nbsp;&#x27;5&nbsp;is&nbsp;less&nbsp;than&nbsp;10&#x27;<br></code></pre><div class = 'comment'>What about value <code>30</code>?</div><pre><code>$value&nbsp;=&nbsp;30;<br>var_dump($type-&gt;explicitlyAccepts($value,&nbsp;$reason));&nbsp;#&nbsp;dumps&nbsp;false<br>var_dump($reason);&nbsp;#&nbsp;dumps&nbsp;&#x27;30&nbsp;is&nbsp;not&nbsp;less&nbsp;than&nbsp;30&#x27;<br></code></pre><div class = 'comment'>But we know <code>30</code> does not even implicitly fit.</div><pre><code>$value&nbsp;=&nbsp;30;<br>var_dump($type-&gt;accepts($value,&nbsp;$reasons));&nbsp;#&nbsp;dumps&nbsp;false<br>var_dump($reasons);<br></code></pre><div class = 'comment'>This function fills the <code>$reasons</code> with an array, reasoning about each failure.</div><pre><code>[<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;identity&#x27;&nbsp;=&gt;&nbsp;&#x27;30&nbsp;is&nbsp;not&nbsp;less&nbsp;than&nbsp;30&#x27;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;unmarshal&#x27;&nbsp;=&gt;&nbsp;&#x27;30&nbsp;is&nbsp;not&nbsp;less&nbsp;than&nbsp;30&#x27;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;unmarshalDatabase&#x27;&nbsp;=&gt;&nbsp;&#x27;40&nbsp;is&nbsp;not&nbsp;less&nbsp;than&nbsp;30&#x27;,<br>]<br></code></pre><div class = 'comment'>The <code>$reason</code> variable can work as a log; for example, we try the code above with <code>5</code> and get the following.</div><pre><code>[<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;identity&#x27;&nbsp;=&gt;&nbsp;&#x27;5&nbsp;is&nbsp;less&nbsp;than&nbsp;10&#x27;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;unmarshal&#x27;&nbsp;=&gt;&nbsp;&#x27;5&nbsp;is&nbsp;less&nbsp;than&nbsp;10&#x27;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&#x27;unmarshalDatabase&#x27;&nbsp;=&gt;&nbsp;null,<br>]<br></code></pre><div class = 'comment'>We can see there is no reason for the <code>unmarshalDatabase</code>, and it makes sense since the value fits using this unmarshal method.</div><div class = 'comment'>We know that the storing in the database is done by marshaling. The marshaled values are in $[0, 20)$.</div><pre><code>var_dump($type-&gt;DatabaseType());&nbsp;#&nbsp;Dumps&nbsp;&#x27;INT(6)&#x27;<br></code></pre><div class = 'comment'>In this case, there is no efficiency since the original values would only need <code>6</code> bits too. Although we could make this better if we shifted the center of the range to zero instead of starting point. That way, we would have the range $[-10, 10)$ which needs only $5$ bits to store. By the way, none of this is useful because MySQL occupies at least a byte which is <code>8</code> bits, and there is no difference between <code>5</code> and <code>6</code> in practice. Although this marshaling method may come in handy for big values, Xua's official <code>Range</code> does not use it because of the ambiguity.</div><div class = 'comment'><a href='#Inside_Xua'><h5 class='heading h5' id='Inside_Xua'> Inside Xua</h5></a>
We may use a Super to define another Super.</div><pre><code>#&nbsp;Supers\Gender<br>Super&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;arguments&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibilities&nbsp;:&nbsp;Range(start&nbsp;=&nbsp;2,&nbsp;end&nbsp;=&nbsp;4)&nbsp;=&nbsp;2;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;predicate&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$choices&nbsp;=&nbsp;[&#x27;male&#x27;,&nbsp;&#x27;female&#x27;];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($this-&gt;possibilities&nbsp;==&nbsp;3)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$choices&nbsp;=&nbsp;[&#x27;male&#x27;,&nbsp;&#x27;female&#x27;,&nbsp;&#x27;non-binary&#x27;];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$message&nbsp;=&nbsp;&#x27;$input&nbsp;is&nbsp;not&nbsp;in&nbsp;&#x27;&nbsp;.&nbsp;implode(&quot;,&nbsp;&quot;,&nbsp;$choices);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;in_array($input,&nbsp;$choices);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre><div class = 'comment'>Note how we set the <code>$message</code> without caring about the return value. Xua automatically clears the <code>$message</code> if the return value is <code>true</code>.</div><div class = 'comment'><a href='#Good_News'><h2 class='heading h2' id='Good_News'> Good News</h2></a>
Although defining a simple Super seems easy, defining a complete Super with all features in many languages seems exhausting. The good news is, Xua provides a set of predefined supers that cover almost any need. We discuss them in the next chapter.</div>

        </div>

        <div id="footer">
            This page has been generated by <a href="http://xuarizmi.ir/">xua</a>
        </div>

        <div id="filler">
        </div>

    </div>

</body>

</html>