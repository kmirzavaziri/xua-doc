# Xua Documentation - Entities
# Kamyar Mirzavaziri
# Winter 1399

# Doc Constants
    # @python doc.constants.TITLE = "Entities;"
    # @python doc.constants.SUBTITLE = "The Beating Heart"

# Doc Configurations
    # @python doc.renderComments = "doc"
    # @python doc.renderCodes = "pure"

# -- #########################################
# # Introduction
# Xua can be configured to communicate with a database server (usually MySQL), but the programmer must specify the database structure. To do so, Xua offers Entity Blocks. Read [Entities](Units.html#Entities) section under [Units](Units.html) chapter for theoretical explanations. In this chapter, we focus on practical details of defining and using entities.

# ## Effects on the projects
# Xua will generate a PHP class extending a Xua abstract class called `Entity` for each Entity Block the programmer creates. These Entity classes are in a one-to-one relationship with database tables, and each row of the table can be corresponded by an instance of the table's corresponding class.

# Also, the same happens in the Marshal Library with respect to the language. However, the front-end clone of the entities only contains method signatures, and the bodies are just network calls.

# ## Terminology

# ### Server Project Side
# A  _Literal Name_ is a literal string containing only alphanumeric characters, starting with a lowercase character. The set of all Literal Names is shown by $\mathbb{L}$.

# The set of all values possible to store in a variable is shown by $\mathbb{X}$.

# A _Dictionary_ is a partial function $D: \mathbb{L} \to \mathbb{X}$ and is usually expressed by all of its records. The set of all dictionaries is shown by $\mathbb{D}$.

# A _Field_ $(T, D)$ is a tuple, where $T \in \mathbb{T}$ is a type (described in [Supers](Supers.html) chapter) called _Field Type_ and $D \in \mathbb{X}$ is a value called _Field Default Value_ (providing $D$ is optional). Note that if $D$ is provided, it is mandatory that $D: T$.

# An _Entity Signature_ is a dictionary $F$ such that $F(s) = (T_s,
# D_s)$
# or $F(s)$ is undefined, where $s$ is a _Field Name_. Domain of the $F$ is called the _Set of Field Names_ of the Entity Signature.

# The set $\{ \mathsf{ASC}, \mathsf{DESC} \}$ is called the set of all _Order Indicators_ and is shown by $\mathbb{O}$.

# An _Index_ is a $k$-tuple of tuples $(f, o)$ with an extra boolean determining if the index is _unique_, where $f$ is a Field Name, and $o \in \mathbb{O}$ is an Order Indicator. Indexes are used in the MySQL engine for faster `select` queries. We try to have a simple explanation here. Let $i_0 = 
# \Big( \big( (f_0,
# o_0), \dots,
# (f_n,
# o_n) \big), u \Big)$ be an Index.
# Intuitively speaking, The MySQL engine will create a list of pointers to data rows, sorted by the mentioned field, which makes it faster to search on those fields. Also if the Index is marked as unique, i.e., $u = \mathsf{1}$, the combination of fields must be unique in data, i.e., we cannot have two rows with same value of $f_0$,
# same value of $f_1$,
# ..., and
# same value of $f_n$ at the same time.

# An _Entity Indexes_ is a set of indexes $I$.

# An _Entity Validation_ is a function with no output that inputs a data row and checks if the data is valid. In case of invalid data, an exception is thrown. For example, assume we store data about some events, each event has two fields, `start_time` and
# `end_time`, and the start must be sooner than the end. The Entity Validation checks if this condition holds, and if the end is sooner than the start, it will throw an `EntityFieldException`.

# An _Entity Class_ is a triplet $(F, I, V)$ of fields, indexes, and the validation function.

# An _Entity Instance_ is an instance of an entity class, which contains actual values for entity fields.

# ### MySQL Side
# A _database_ is a set of _table_s; each table has a _structure_ consisting of _column_s, and a set of _row_s as _data_.

# _insert_ is the action of adding new rows to a table.

# _select_ is the action of retrieving table rows on some specific conditions.

# _update_ is the action of modifying some table rows on some specific conditions.

# _delete_ is the action of removing some table rows on some specific conditions.

# ### Correspondence
# Each _table_ is in one-to-one correspondence with an _Entity Class_. Methods of these classes can communicate with the database server to select, insert, update, and delete data. _Field_s of the entity class represent the _column_s of the table, and _instance_s of the class represent the _row_s of the table. 

# -- #########################################
# # Definition

# ## Structure
# An entity block has the following structure.

# @python doc.renderComments = "pure"
# Path\To\Entity\EntityName
 
# Description of what this Entity is all about, probably in markdown formatting.
 
Entity [extends Path\To\Another\Entity\EntityName] {
    fields {
        field0 : type0 [= DEFAULT_0]; # Description of field0
        ...                         ; # ...
        fieldN : typeN [= DEFAULT_0]; # Description of fieldN
    }
    [ indexes : {
        ([-]filedName00, ..., [-]fieldName0K)[*]; # Description of index number 0
        ...                                     ; # ...
        ([-]filedNameM0, ..., [-]fieldNameML)[*]; # Description of index number M
    } ]
    [ validation : { VALIDATION_BODY } ]
    [ override<METHOD_NAME_0> { METHOD_0_BODY } ]
    ...
    [ override<METHOD_NAME_P> { METHOD_P_BODY } ]
}
# @python doc.renderComments = "doc"

# Note that there is no name for the Entity. An Entity name is its file path. Each file can contain at most one block, and the block inherits its name from the file. It is a good practice to have a comment in the first line of the file describing where the file is located.

# __Note.__ All entities have a read-only field called `id`, of its own type `Identifier()`, defined implicitly. The field `id` is used in some underlying Xua codes and cannot be removed.

# ## Fields
# Each Entity represents a class and is responsible for storing properties of its instances as data in the database. The object (instance) can have different properties, each with its type and default value. These properties are called fields and should be defined with their type and default value in the `fields` part.

# ## Indexes
# An index is a list of fields along with a boolean determining if the index is unique. Indexes are used in the database engine for faster `select` queries. All fields are assumed to be ascending by default unless the programmer specifies one as descending by a `-` sign before it, which tells the database engine to sort that field in descending order. A `*` sign at the end of an index definition makes it a unique index. If the index is marked as unique, the combination of fields must be unique in data. Note that the implicit field `id` is a unique field by default.

# ## Validation
# The body of the `validation` block is written in pure PHP. 

# The `validation` block is responsible for checking if an instance of the Entity is valid, and in case of invalid data, an `EntityFieldException` must be thrown. For example, assume we have a table of restaurants in an entity called `Restaurant`. This Entity has two fields, `title` and `active`. The `title` field is unique, but it is impossible to mark it as a unique index in `indexes` because we may have many inactive records sharing the same title, and the title is unique among the active restaurants. (there is a workaround here to solve this problem only using `indexes`, but for the purpose of this documentation, we assume there is not.) We can check this in the `validation` block and throw an `EntityFieldException` if the title is duplicate.

# ## Overriding Methods
# Xua generates a PHP class from each entity, extending `Entity`. This class have many methods which are possible to override. Here is a list of these methods, with the PHP method that is actually being overridden.
#    Override<initialize> => protected static _initialize(string $caller);
#    Override<getOne>     => protected static _getOne(Condition $condition, Order $order, string $caller);
#    Override<store>      => public _store(string $caller);
#    Override<delete>     => protected _delete(string $caller);
#    Override<getMany>    => protected static _getMany(Condition $condition, Order $order, Pager $pager, string $caller);
#    Override<countMany>  => protected static _countMany(Condition $condition, Order $order, Pager $pager, string $caller);
#    Override<deleteMany> => protected static _deleteMany(Condition $condition, Order $order, Pager $pager, string $caller);
#    Override<setMany>    => protected static _setMany(array $changes, Condition $condition, Order $order, Pager $pager, string $caller);

# Xua provides final methods that include the actual logic, which one can use when overriding a method. Here is a list of these method names. 

# | Name in `.xua` file | Original Method       |
# | ------------------- |---------------------- |
# | `<initialize>`      | &#95;x&#95;initialize |
# | `<getOne>`          | &#95;x&#95;getOne     |
# | `<store>`           | &#95;x&#95;store      |
# | `<delete>`          | &#95;x&#95;delete     |
# | `<getMany>`         | &#95;x&#95;getMany    |
# | `<countMany>`       | &#95;x&#95;countMany  |
# | `<deleteMany>`      | &#95;x&#95;deleteMany |
# | `<setMany>`         | &#95;x&#95;setMany    |



# So, as an example, one can override the `store` procedure like this.
#    Override<store> {
#        if (isset(static::fieldSignatures()['updatedAt'])) {
#            $this->updatedAt = DateTimeService::now();
#        }
#        try {
#            $return = static::_x_store(); // original Xua's store logic
#            LogService::logDatabaseChange($this);
#        } catch (Exception as $e) {
#            LogService::logDatabaseException($e);
#        }
#        return $return;
#    }
# Usually, the original methods suffice, and there is no need to override them, but in case of necessity, be careful not to corrupt the functionality.

# ## Hierarchy
# Entities can come in a hierarchy just like PHP classes, and the `validation` block is a class method.
#    protected function _validation();

# Also, the fields and indexes of a child entity override the ones in the parent. This override includes the type and default value. Also, it is possible to add new fields or indexes to the type, but it is not possible to remove existing fields. Read [Examples](#Examples) for more details.

# ## Visibility
# The visibility of entities is controlled by overriding methods. There is an additional variable accessible in all methods, including validation, called `$caller`. This variable contains a string telling what party called this method. The values are accessible as class constants in the class `\Xua\Tools\Visibility`. These values are `Visibility::CALLER_PHP`,
# `Visibility::CALLER_DART`, etc.

# So it's possible to block foreign callers like the following.
#    if ($caller != Visibility::CALLER_PHP) {
#        throw AccessForbiddenException();
#    }

# But there is more than this. It's possible to customize procedures according to the caller. For example
#    if ($caller != Visibility::CALLER_PHP) {
#        if ($this->id) {
#            if (!UserService::hasAccess(AccessService::MODIFY_SOME_ENTITY)) {
#                throw AccessForbiddenException();
#            }
#        } else
#            if (!UserService::hasAccess(AccessService::CREATE_SOME_ENTITY)) {
#                throw AccessForbiddenException();
#            }
#        }
#    }
#    $this->updatedByCaller = $caller;

# __Note.__ Accessing The entities through `URPI` is disabled by default, and therefore the `$caller` is always PHP. One can enable this feature, but they must be super careful since it may result in severe vulnerabilities.

# -- #########################################
# # Special Field Types
# In addition to defined supers that can be called to generate type for field types, Xua offers two categories of unusual types that make the development of a project significantly easier and faster and the resulting project more efficient and more secure. Here we try to cover these two outstanding features of Xua.

# ## Virtual Field Supers
# In some cases, one needs some fields for an entity that does not contain new data, so if defined as regular fields, this will result in duplicate/not-synced data. These supers will help mix up other fields and generate a new field that is calculated each time called but not stored. There are two types of virtual supers. One is calculated by the PHP engine and the other by the database engine. The _Database Virtual Field_ is used when the programmer wants to use the result in a query, e.g., using in condition or order, while the _PHP Virtual Field_ is used for more complicated mixtures of fields.

# ### PHP Virtual Field
# The PHP Virtual Field has the following signature.
#    PHPVirtualField{
#        arguments {
#            getter: Callback(
#                nullable = false,
#                parameters = [
#                    {
#                        name:            null,
#                        type:            @php(Entity::class),
#                        allowSubtype:    true,
#                        required:        true,
#                        checkDefault:    false,
#                        default:         null,
#                        passByReference: false,
#                    },
#                ]
#            );
#            setter: Callback(
#                nullable = true,
#                parameters = [
#                    {
#                        name:            null,
#                        type:            @php(Entity::class),
#                        allowSubtype:    true,
#                        required:        true,
#                        checkDefault:    false,
#                        default:         null,
#                        passByReference: true,
#                    },
#                    {
#                        name:            null,
#                        type:            null,
#                        allowSubtype:    true,
#                        required:        true,
#                        checkDefault:    false,
#                        default:         null,
#                        passByReference: false,
#                    },
#                ]
#            ) = null;
#        }
#        ...
#    }

# #### PHP Virtual Field Example
# Let us say we have fields `gender`, `firstName`, and `lastName` in entity `User`, and want to create a field called `title` based on these fields. We can define it like this.

#    title : PHPVirtualField (
#        getter = (User $user) => {
#            if ($user->gender == User::GENDER_MALE) {
#                $honorific = "Mr ";
#            } elseif ($user->gender == self::GENDER_FEMALE) {
#                $honorific = "Miss ";
#            } else {
#                $honorific = "";
#            }
#            return $honorific . $user->firstName . " " . $user->lastName;
#        }
#    );

# ### Database Virtual Field
# The Database Virtual Field has the following signature.
#    DatabaseVirtualField{
#        arguments {
#            getter: Callback(
#                nullable = false,
#                parameters = [
#                    {
#                        name:            null,
#                        type:            @php(Entity::class),
#                        allowSubtype:    true,
#                        required:        true,
#                        checkDefault:    false,
#                        default:         null,
#                        passByReference: false,
#                    },
#                    {
#                        name:            'params',
#                        type:            'array',
#                        allowSubtype:    true,
#                        required:        true,
#                        checkDefault:    false,
#                        default:         null,
#                        passByReference: false,
#                    },
#                ]
#            );
#        }
#        ...
#    }

# Note that one cannot set a database virtual field, and therefore there is no setter method available on this field.

# Note that another method argument is available called `params`, which is used to pass some extra parameters into the getter method. We discuss it in more depth in the Example section.

# #### Database Virtual Field Example
# Let us say that we have an entity called `City`, and we need a field that tells if the city is a town or a big city. At the moment, we consider cities that have a population of less than a million to be town, but this might change; either the population may change, or we may think of the area as an item, or we can have a more complicated way that involves both population and area of a city. So we cannot calculate the field `isTown` each time we need it somewhere (this may result in duplicate code). Instead, we need a field that does this so we can change it later and the change affect all usages. We can do this by defining the field `isTown` this way.
#    isTown : DatabaseVirtualField (
#        getter (City $city, array $params) => {
#            return "{self::F_population()->name} < 1000000";
#        }
#    )

# For a more complex example, consider this scenario. Let us say that we have an entity called `Restaurant`, and we want to sort the restaurants by distance in ascending order, so we need a field called distance. A PHP Virtual Field can do this, but in that case, we need to fetch all restaurants from the database server and then sort them, which takes a significant amount of time and space. Instead, we can define it as a Database Virtual Field that allows us to use it while creating an order expression and tell the database server to sort the restaurants by itself and give us the first page. We define this field using the following code.
distance : DatabaseVirtualField (
    getter (City $city, array $params) => {
        here = $params['here']; # Here, one can understand the application of the params argument.
        $lat0 = "(PI() * {$here->lat} / 180)";
        $long0 = "(PI() * {$here->long} / 180)";

        $lat1 = "(PI() * {self::F_geoLat()->name} / 180)";
        $long1 = "(PI() * {self::F_geoLong()->name} / 180)";

        $a = "(
            POWER(SIN(($lat0 - $lat1) / 2), 2) +
            COS($lat0) *
            COS($lat1) *
            POWER(SIN(($long0 - $long1) / 2), 2)			
        )";
        $c = "(2 * ATAN2(POWER($a, .5), POWER(1 - $a, .5)))";
        $d = "6371000 * $c";

        return $d;
    }
)

# ## Entity Relation
# In almost any back-end project, some Entities are in relation with each other. For example, in a simple food delivery app, restaurants are handling orders, orders have items, items are being liked/ commented by users, users are ordering orders, restaurants are being liked/ commented by users, etc.

# There is a unique and special Super called `EntityRelation` responsible for handling such relations.

# But before we discuss this Super, we need to discuss different relations classes based on how we implement them.

# ### A Little Formalism on Relation Classes
# Assume $\mathcal{A}$ and $\mathcal{B}$ are two Entities, and $A$ and $B$ are sets of their instances, respectively. $R \subseteq A \times B$ is called a relation between $\mathcal{A}$ and $\mathcal{B}$. We define nine different classes of relations based on how we implement them. Any possible relation fits in one of these classes; actually, all of them fit in $\mathsf{NN}$. However, choosing the best class when defining the database structure is a matter of restriction and efficiency.

# _1_. $\mathsf{O11O}$ (_Optional one-to-one Optional_) is the class of all relations with the following conditions.
# \begin{eqnarray*}
# & i. & \forall a \in A, |\{ b \in B : aRb \}| \leq 1 \\
# & ii. & \forall b \in B, |\{ a \in A : aRb \}| \leq 1
# \end{eqnarray*}

# _2_. $\mathsf{O11R}$ (_Optional one-to-one Required_) is the class of all relations with the following conditions.
# \begin{eqnarray*}
# & i. & \forall a \in A, |\{ b \in B : aRb \}| \leq 1 \\
# & ii. & \forall b \in B, |\{ a \in A : aRb \}| = 1
# \end{eqnarray*}

# _3_. $\mathsf{R11O}$ (_Required one-to-one Optional_) is the class of all relations with the following conditions.
# \begin{eqnarray*}
# & i. & \forall a \in A, |\{ b \in B : aRb \}| = 1 \\
# & ii. & \forall b \in B, |\{ a \in A : aRb \}| \leq 1
# \end{eqnarray*}

# _4_. $\mathsf{R11R}$ (_Required one-to-one Required_) is the class of all relations with the following conditions.
# \begin{eqnarray*}
# & i. & \forall a \in A, |\{ b \in B : aRb \}| = 1 \\
# & ii. & \forall b \in B, |\{ a \in A : aRb \}| = 1
# \end{eqnarray*}

# _5_. $\mathsf{ON1}$ (_Optional many-to-one_) is the class of all relations with the following condition.
# \begin{eqnarray*}
# \forall a \in A, |\{ b \in B : aRb \}| \leq 1
# \end{eqnarray*}

# _6_. $\mathsf{RN1}$ (_Required many-to-one_) is the class of all relations with the following condition.
# \begin{eqnarray*}
# \forall a \in A, |\{ b \in B : aRb \}| = 1
# \end{eqnarray*}

# _7_. $\mathsf{1NO}$ (_one-to-many Optional_) is the class of all relations with the following condition.
# \begin{eqnarray*}
# \forall b \in B, |\{ a \in A : aRb \}| \leq 1
# \end{eqnarray*}

# _8_. $\mathsf{1NR}$ (_one-to-many Required_) is the class of all relations with the following condition.
# \begin{eqnarray*}
# \forall b \in B, |\{ a \in A : aRb \}| = 1
# \end{eqnarray*}

# _9_. $\mathsf{NN}$ (_many-to-many_) is the class of all relations.

# ### The Signature
# The `EntityRelation` has the following signature.
#    EntityRelation{
#        arguments {
#            # Standard Arguments
#                  relatedEntity : Universal(                            )        ;
#                  relation      : Enum     (values   = self::REL_       )        ;
#                  invName       : Symbol   (nullable = true             ) = null ;
#            # Constant Arguments
#            const fromMany      : Boolean  (                            ) = false;
#            const fromOne       : Boolean  (                            ) = false;
#            const toMany        : Boolean  (                            ) = false;
#            const toOne         : Boolean  (                            ) = false;
#            const is11          : Boolean  (                            ) = false;
#            const isN1          : Boolean  (                            ) = false;
#            const is1N          : Boolean  (                            ) = false;
#            const isNN          : Boolean  (                            ) = false;
#            const optional      : Boolean  (                            ) = false;
#            const nullable      : Boolean  (                            ) = false;
#            const required      : Boolean  (                            ) = false;
#            const invOptional   : Boolean  (                            ) = false;
#            const invRequired   : Boolean  (                            ) = false;
#            const hasJunction   : Boolean  (                            ) = false;
#            # Definition Side Arguments
#                  definedOn     : Enum     (values   = self::DEFINED_ON_)        ;
#            const definedHere   : Boolean  (                            ) = false;
#            const definedThere  : Boolean  (                            ) = false;
#            const columnHere    : Boolean  (                            ) = false;
#            const columnThere   : Boolean  (                            ) = false;
#        }
#        ...
#    }

# #### Related Entity
# To create a relation $R$ between two Entities $\mathcal{L}$ and $\mathcal{R}$, one has to define a field that represents $R$ with a type generated from the `EntityRelation` Super. The field must be defined on $\mathcal{L}$ (called the _Left Entity_), and the `relatedEntity` must be set to $\mathcal{R}$ (called the _Right Entity_).


# #### Relation Class
# The `relation` argument determines the class of the relation and has one of the following values.
#    EntityRelation::REL_O11O
#    EntityRelation::REL_O11R
#    EntityRelation::REL_R11O
#    EntityRelation::REL_R11R
#    EntityRelation::REL_ON1
#    EntityRelation::REL_RN1
#    EntityRelation::REL_1NO
#    EntityRelation::REL_1NR
#    EntityRelation::REL_NN

# #### Name & Inverse Name
# One can use this field to get all the related rows of a row in the database. The `invName` argument is used to do the inverse job. We try to make it clear by an example.

# Assume one defines a field called `rel` on the `LeftEntity` like this.
#    LeftEntity {
#        fields {
#            ...
#            rel : EntityRelation(
#                relatedEntity = @php(RightEntity::class),
#                relation = EntityRelation::REL_NN,
#                invName = 'invRel',
#            )
#            ...
#        }
#        ...
#    }

# The Xua engine automatically generates an implicit field like this.
#    RightEntity {
#        fields {
#            ...
#            invRel : EntityRelation(
#                relatedEntity = @php(LeftEntity::class),
#                relation = EntityRelation::REL_NN,
#                invName = 'rel',
#            )
#            ...
#        }
#        ...
#    }

# Now, one can access the related instances using these fields.
#    $l = new LeftEntity();
#    // $l->rel is the set of all instances of RightEntity $r s.t. $l is in relation with $r.
#    $r = new RightEntity();
#    // $r->invRel is the set of all instances of LeftEntity $l s.t. $l is in relation with $r.

# __Note.__ in the X-to-one cases, the result of retrieving a field is not a set but instead a value that can be an empty Entity in optional cases.

# __Note.__ the `invName` argument is optional, and if it is not provided, the Xua engine does not generate the implicit inverse field.

# #### Constant Arguments
# `EntityRelation` offers a set of constant arguments calculated based on the relation class, that help with recognizing a relation better. The names are pretty explanatory by themselves, but here we provide the way we calculate each.

#    $this->fromMany     = in_array($this->relation, [self::REL_NN, self::REL_ON1, self::REL_RN1]);
#    $this->fromOne      = !$this->fromMany;
#    $this->toMany       = in_array($this->relation, [self::REL_NN, self::REL_1NO, self::REL_1NR]);
#    $this->toOne        = !$this->toMany;
#    $this->is11         = ($this->fromOne and $this->toOne);
#    $this->isN1         = ($this->fromMany and $this->toOne);
#    $this->is1N         = ($this->fromOne and $this->toMany);
#    $this->isNN         = ($this->fromMany and $this->toMany);
#    $this->optional     = in_array($this->relation, [self::REL_O11O, self::REL_O11R, self::REL_ON1]);
#    $this->nullable     = $this->optional;
#    $this->required     = !$this->optional;
#    $this->invOptional  = in_array($this->relation, [self::REL_O11O, self::REL_R11O, self::REL_1NO]);
#    $this->invRequired  = !$this->invOptional;
#    $this->hasJunction  = $this->isNN;

# #### Definition Side Arguments
# There is a particular argument called `definedOn` which can either be `here` or `there`. This argument is not to be filled by the Xua programmer. If a relational field is defined explicitly on an Entity, the Xua engine sets this argument to `here`, and for the implicit inverse field, the value of this argument is `there`. There are also some constant fields in this regard; all of these arguments are used by the Xua core to decide how to store and process data. 
#    $this->definedHere  = ($this->definedOn == self::DEFINED_ON_HERE);
#    $this->definedThere = ($this->definedOn == self::DEFINED_ON_THERE);
#    $this->columnHere   = (($this->is11 and $this->definedHere) or $this->isN1);
#    $this->columnThere  = (($this->is11 and $this->definedThere) or $this->is1N);

# ### Entity Relation Example
# For example, assume we have two Entities called `User` and `City`. Further, assume we want a field in the `User` entity called `currentCity`, and we want this field to refer to a row of the `City` table. We have to add the following field to the `User` entity.

#    User {
#        fields {
#            ...
#            currentCity : EntityRelation(
#                relatedEntity = @php(City::class),
#                relation = EntityRelation::REL_RNI,
#                invName = 'citizens',
#            )
#            ...
#        }
#        ...
#    }

# __Relation.__ The `EntityRelation::REL_RNI` stands for a many-to-one relation required on the left side, which means that no user can be in more than one city simultaneously but needs to be in a city, although one city can have many citizens at once.

# __Inverse Name.__ Here, we created a field called `currentCity` that shows us a relation between users and cities, and we can get related cities of a user by `$user->currentCity`, but how can we get related users of a city? The Xua engine generates an implicit field based on the `invName`. So `$city->citizens` gives us the list of all users that their `currentCity` is `$city`.

# -- #########################################
# # Helper Classes

# ## Field Class
# Each field defined under a name is accessible as the static method `F_{fieldName}()` of the entity class. This property is an instance of a class called `EntityFieldSignature`. This class has the following structure.
#    public string   $entity,
#    public string   $name,
#    public Super    $type,
#    public mixed    $default = null,
#    public function p(?array $param = null): array|EntityFieldSignature;

# ### Field Class Example
# Assume the [Database Virtual Field Example](#Database_Virtual_Field_Example) we have provided above. Here we work a little around the field `$restaurant->distance`.

# Notations `Restaurant::fieldSignatures()['distance']` and `Restaurant::F_distance()` both refer to the same value, an instance of class `EntityFieldSignature` describing this field. So we know the following expressions are true.

#    Restaurant::F_distance()->entity  == Restaurant::class;
#    Restaurant::F_distance()->name    == 'distance';
#    Restaurant::F_distance()->type    == DatabaseVirtualField (...);
#    Restaurant::F_distance()->default == null;
#    // The parameters of a field is null by default.
#    Restaurant::F_distance()->p()     == null;
#    // We can modify the parameters of a field by calling the method `p` on its signature.
#    Restaurant::F_distance()->p(['here' => (object)['lat' => 42, 'long' => 59]]); // https://en.wikipedia.org/wiki/Khwarazm
#    // Now it's set.
#    Restaurant::F_distance()->p()     == ['here' => (object)['lat' => 42, 'long' => 59]];

# ## Conditional Field Class
# The `ConditionField` class is similar to the regular field class but has some features used in defining conditions and orders, which we discuss later. The Condition Field of each field is accessible as the static method `C_{fieldName}()` of the entity class. This class has the following structure.
#    public function __construct(public EntityFieldSignature $signature);
#    public function rel(ConditionField $conditionField): static;
#    public function name() : string;
#    public function joins(): array;

# So the `SomeEntity::C_field()`
# is actually `new ConditionField(SomeEntity::F_field())`, an instance of `ConditionField` based on the field signature.

# The critical feature of this class is the `rel` method, which makes it possible to access fields on the related tables. We cover this in the following sections.

# The methods `name` and `joins` are not usually helpful for the Xua programmer and are used in the Xua core. So we do not cover them here.

# ## Condition
# _Condition_ is a Xua built-in class that we use to create _WHERE expressions_ with. Each instance of Condition is a node in a binary tree. There are two ways two create an instance of this class.

@TODO Continue from HERE.

# ## Order

# ## Pager

# -- #########################################
# # Practicalities

# ## Deploy & Alters
# When a new entity is created, or an entity is modified, these changes should be synced with the mysql server. The deploy procedure adds new created entities as tables to the database, and also generates `ALTER` queries for modified entities. The deploy procedure does not run the alters by itself, instead, it prints out the alters; which are possible to run by the programmer or another person in charge. It's possible to complete the deploy process with the undone alters. This process is called _force deploy_, and the alters which are possible to ignore while deploying are called _force-friendly alters_.

# -- #########################################
# # Usage
# It's possible to use a defined entity in both server project (PHP language) and front-end native codes via marshal library, but not in Xua language.

# ## Inside PHP

# ### Make a type
# The following code makes a type by giving arguments to a super.
#    $type = new Path\To\Super\SuperName([
#        'argName0' => $value0,
#        ...,
#        'argNameN' => $valueN,
#    ]);

# ### Determine a type
# Assume a type is given in a variable and we need to know what type is it. We can try to find the class of the object but what about arguments? It's almost impossible to get the type accurate unless we have a method for that. The following method returns a string that describes the type.
#    var_dump($type->toString());
# This code dumps `'Path\To\Super\SuperName(argName0 = value0, ..., argNameN = valueN)'`.

# ### Accepts, Implicit & Explicit
# There are three `accepts` functions for a type.

# #### explicitlyAccepts
# This function will return true only if the value explicitly fits in the type. The second argument is optional, and if the return value is false, the function may fill it with a reason.
#    if ($type->explicitlyAccepts($value, $reason)) {
#        var_dump($value);
#        echo 'is of type ' . $type->toString();
#    } else {
#        echo 'rejected because of' . $reason;
#    }

# #### implicitlyAccepts
# This function will return true if the value explicitly fits in the type or, fits in the type after unmarshaling. The unmarshaling methods must be determined by caller. The function tries the value itself first, then tries to unmarshal and check if the value fits by given methods, one by one. If not passed to the function, the default value `['unmarshal', 'unmarshalDatabase']` is assumed.
#    if ($type->implicitlyAccepts($value, $reasons, ['unmarshal'])) {
#        var_dump($value);
#        echo 'kinda fits in type ' . $type->toString();
#    } else {
#        echo 'fully rejected because of the following reasons';
#        var_dump($reasons);
#    }

# #### accepts
# This function does the same job of `implicitlyAccepts`, but may alter the original value while trying to fit it in the type.
#    $originalValue = $value;
#    if ($type->accepts($value, $reasons, ['unmarshal'])) {
#        var_dump($originalValue);
#        echo 'was changed to';
#        var_dump($value);
#        echo 'to fit in type ' . $type->toString();
#    } else {
#        echo 'fully rejected because of the following reasons';
#        var_dump($reasons);
#    }

# ### Marshal & Unmarshal
# There are two types of marshal and unmarshal functions available in the server project.

# #### Network transmissions
# Functions `marshal` and `unmarshal` are responsible to marshal and unmarshal values for purpose of network transmissions.
#    $marshaledValue = $type->marshal($value);
#    $reversedValue = $type->unmarshal($marshaledValue);
#    if ($value !== $reversedValue) {
#        var_dump('something is wrong with marshal/unmarshal functions of ' . $type->toString());
#    }

# #### Database Storing & Restoring
# Functions `marshalDatabase` and `unmarshalDatabase` are responsible to marshal and unmarshal values for purpose of storing and restoring into/from database.
#    $marshaledValue = $type->marshalDatabase($value);
#    $reversedValue = $type->unmarshalDatabase($marshaledValue);
#    if ($value !== $reversedValue) {
#        var_dump('something is wrong with marshalDatabase/unmarshalDatabase functions of ' . $type->toString());
#    }

# ### Database Type
# The function `DatabaseType` is a function with no arguments that returns an string which tells the database how the type values must be stored. And is hardly useful in programming.

# ## Inside Xua
# The main usage of supers is to declare types for Xua super arguments, entity fields, and method request and response signatures. To mention a type, one must call a super and give it arguments. The type then, can be used for type declaration. The syntax is the following.
#    Path\To\Super\SuperName(
#        argName0 = constant0,
#        ...,
#        argNameN = constantN,
#    )

# -- #########################################
# # Examples

# ## Range
# In this section, we want to work with a super type that accepts a range of integers $[a, b)$.

# ### Definition
# First of all, we need to define the super. we put it in the file `Supers/Integers/Range.xua`.

# #### Arguments
# We need to have two arguments determining start and end of the range. The arguments must be integer themselves.

# @python doc.renderComments = "pure"
# Supers\Integers\Range
Super (
    start : Supers\Integers\Integer();
    end   : Supers\Integers\Integer();
) {
    # TODO implement
}
# @python doc.renderComments = "doc"

# #### Validation
# For the validation, we must check that the second number is not less than the first one. Note that we do not need to check if the type of arguments is integer since we already declared their type so the type checking is automated.
#    Validation {
#        if ($this->args['end'] < $this->args['start']) {
#            throw new SuperValidationException('Argument end cannot be less than start.');
#        }
#    }

# #### Predicate
# We can just simply check if the `$input` value is in the range.
#    Predicate {
#        return $this->args['start'] <= $input && $input < $this->args['end'];
#    }
# But we can make it a little more sophisticated by providing a reason of why the value may fail to fit.
#    Predicate {
#        if (!($this->args['start'] <= $input)) {
#            $message = $input . ' is less than ' . $this->args['start'];
#            return false;
#        }
#        if (!($input < $this->args['end'])) {
#            $message = $input . ' is not less than ' . $this->args['end'];
#            return false;
#        }
#        return true;
#    }
# Note that it's OK to fill the $reason when the return value is `true`. Xua automatically clears the `$message` in that case.


# #### Marshal and Unmarshal
# Since the integers are possible to store and transmit, we can leave the marshal and unmarshal functions identity. But for the purpose of this documentation, we define a network transmit marshaling system, and leave the database store marshaling identity.

# The silly idea is to shift starting number to zero to have smaller integers which are easier to transmit (it's not). For example The range $[1000, 1100)$ can be shifted to $[0, 100)$.
#    Marshal<php> {
#        return $input - $this->args['start'];
#    }
#    Unmarshal<php> {
#        return $input + $this->args['start'];
#    }
#    Marshal<javascript> {
#        return input - this.args.start;
#    }
#    Unmarshal<javascript> {
#        return input + this.args.start;
#    }

# #### Database Type
# This is an interesting part of the definition, since we can actually determine the length of MySQL `INT` by the range limits.

# We know that `INT(n)` can store values in range $[-2^{n-1}, 2^{n-1}]$. So we need to find the least $n$ such that this range contains our range. First, we find the maximum absolute value that can fit in the type.
#    $min = $this->args['start'];
#    $max = $this->args['end'] - 1;
#    $absMax = max(abs($min), abs($max));

# Let's say this number is $M$. we must find $n$ such that $M \leq 2^{n-1}$.
# $$\begin{eqnarray}
# M \leq 2^{n-1} & \iff & \log_2(M) \leq n - 1 \\
# (\text{Since $n - 1$ is integer}) & \iff & \lceil \log_2(M) \rceil \leq n - 1 \\
# & \iff & \lceil \log_2(M) \rceil + 1 \leq n \\
# \end{eqnarray}$$

# Do the minimum value of $n$ is when $n = \lceil \log_2(M) \rceil + 1$.
#    $n = ceil(log($absMax, 2)) + 1;

# This leads us to the following `DatabaseType`.
#    DatabaseType {
#        $min = $this->args['start'];
#        $max = $this->args['end'] - 1;
#        $absMax = max(abs($min), abs($max));
#        $n = ceil(log($absMax, 2)) + 1;
#        return "INT($n)";
#    }

# #### Hierarchy
# Assume that we want another super with same features, but only for positive values. We can just extend what we already have.

# @python doc.renderComments = "pure"
# Supers\Integers\PositiveRange
Super extends Supers\Integers\Range () {
    Validation {
        if ($this->args['start] <= 0) {
            throw new SuperValidationException('The range must be positive');
        }
        parent::validation();
    }
}
# @python doc.renderComments = "doc"

# Or assume we want a range super that can only start at zero.

# @python doc.renderComments = "pure"
# Supers\Integers\NaturalUpperLimit
Super extends Supers\Integers\Range (
    const start : Supers\Integers\Integer() = 0;
) {}
# @python doc.renderComments = "doc"

# Note the way we overrode the `start` with default value, but also set it constant so the caller cannot change it.
#    $type = new Supers\Integers\NaturalUpperLimit(['start' => 1, 'end' => 2]);
# This code will result in uncaught `SuperValidationException`.

# But better than these, assume we use the network transmit marshaling procedures for database which can really make an impact. And also remove the silly network transmit marshaling procedure. But we must override the `DatabaseType` as well.

# @python doc.renderComments = "pure"
# Supers\Integers\EfficientRange
Super extends Supers\Integers\Range () {
    Marshal<php> {
        return $input;
    }
    Unmarshal<php> {
        return $input;
    }
    Marshal<javascript> {
        return $input;
    }
    Unmarshal<javascript> {
        return $input;
    }

    Marshal<database> {
        return $input - $this->args['start'];
    }
    Unmarshal<database> {
        return $input + $this->args['start'];
    }
    DatabaseType {
        $max = $this->args['end'] - $this->args['start'] - 1;
        $n = ceil(log($max, 2)) + 1;
        return "INT($n)";
    }
}
# @python doc.renderComments = "doc"

# Another example is when we want to add arguments to a super. For example assume we want an `step` argument. By default the step is one. but if we set step to three, then the type accepts `start` and every third number.

# @python doc.renderComments = "pure"
# Supers\Integers\StepRange
Super extends Supers\Integers\Range (
    step : Supers\Integers\Integer() = 1;
) {
    Validation {
        parent::validation();
        if (step < 1) {
            throw new SuperValidationException('step must be at least 1.');
        }
    }
    Predicate {
        if (!parent::predicate($input, $message)) {
            return false;
        }
        if ($input - $this->argument['start'] % $this->argument['step'] != 0) {
            $message = "value {$input} minus starting point {$this->argument['start']} is not devisable by step value {$this->argument['step']}.";
            return false;
        }
        return true;
    }
}
# @python doc.renderComments = "doc"


# ### Usage
# After defining a super, we can use it to define types, and use them.

# #### Inside PHP
# First, Let's define a type that accepts the range $[10, 30)$. We use the `EfficientRange`.
#    $type = new Supers\Integers\EfficientRange(['start' => 10, 'end' => 30]);

# Let's see what how Xua stringifies this type.
#    var_dump($type->toString());
# This code dumps `Supers\Integers\EfficientRange(start = 10, end = 30)`.

# The value `25` explicitly fits in the type, while the value `5` implicitly fits.
#    $value = 25;
#    var_dump($type->explicitlyAccepts($value)); # dumps true
#    $value = 5;
#    var_dump($type->implicitlyAccepts($value)); # dumps true

# Of course the value `25` also fits in the type implicitly. This is because the function first checks if the value explicitly fits.
#    $value = 25;
#    var_dump($type->implicitlyAccepts($value)); # dumps true

# We know value `15` is ambiguous. It can be interpreted as `15` itself, a value in range, or the result of marshaling `25`. Let's call accept and check the result.
#    $value = 15;
#    var_dump($type->accepts($value)); # dumps true
#    var_dump($value); # dumps 15
# Since the function first tries the explicit, if the value fits explicitly, function doesn't change the value. What about `5` that can only fit implicitly?
#    $value = 5;
#    var_dump($type->accepts($value)); # dumps true
#    var_dump($value); # dumps 15
# This time the function tries to fit the value explicitly and fails, so it goes for unamrshaling, which leads to accept.

# We know the value $5$ doesn't fit explicitly, but we may wonder why. (It's super obvious but is a good way to see how to get the reason from the function.)
#    $value = 5;
#    var_dump($type->explicitlyAccepts($value, $reason)); # dumps false
#    var_dump($reason); # dumps '5 is less than 10'
# What about value `30`?
#    $value = 30;
#    var_dump($type->explicitlyAccepts($value, $reason)); # dumps false
#    var_dump($reason); # dumps '30 is not less than 30'
# But we know `30` doesn't even implicitly fit.
#    $value = 30;
#    var_dump($type->accepts($value, $reasons)); # dumps false
#    var_dump($reasons);
# This function fills the `$reasons` with an array, reasoning about each failure.
#    [
#        'identity' => '30 is not less than 30',
#        'unmarshal' => '30 is not less than 30',
#        'unmarshalDatabase' => '40 is not less than 30',
#    ]
# The `$reason` variable can work like a log, for example we try the code above with `5`, and get the following.
#    [
#        'identity' => '5 is less than 10',
#        'unmarshal' => '5 is less than 10',
#        'unmarshalDatabase' => null,
#    ]
# We can see there is no reason for the `unmarshalDatabase`, and it makes sense since the value fitted.

# We know that the storing in the database is done by marshalling. The marshaled values are in $[0, 20)$.
#    var_dump($type->DatabaseType()); # Dumps 'INT(6)'
# In this case there is no efficiency since the original values would only need `6` bits to. Although we could make this better if we shifted the center of the range to zero instead of starting point. That way we would have range $[-10, 10)$ which needs only $5$ bits ro store. Any way none of this is useful because MySQL occupies at least a byte which is `8` bits. And there is no difference between `5` and `6` in practice. Although this method of marshaling may come handy for big values, Xua's official `Range` does not use it because of the ambiguity.


# #### Inside Xua
# We may use a super to define another super.
# @python doc.renderComments = "pure"
# Supers\Gender
Super (
    possibilities : Supers\Integers\Range(start = 2, end = 4) = 2;
) {
    Predicate {
        $choices = ['male', 'female'];
        if ($this->args['possibilities'] == 3) {
            $choices = ['male', 'female', 'third'];
        }

        $message = '$input is not in ' . implode(", ", $choices);
        return in_array($input, $choices);

    }
}
# @python doc.renderComments = "doc"

# Note how we set the `$message` without caring about the return value. Xua automatically clears the `$message` if the return value is `true`.

# -- #########################################
# # Good News
# Although defining a simple super seems easy, defining a complete super with all features in many languages, seems exhausting. The good news is, Xua provides a set of predefined supers that cover almost any need. We discuss them in the next chapter. 