# XUA Documentation - Units
# Kamyar Mirzavaziri
# Winter 1399

# Doc Constants
    # @python doc.constants.TITLE = "Units;"
    # @python doc.constants.SUBTITLE = "The Fundamentals"

# Doc Configurations
    # @python doc.renderComments = "doc"
    # @python doc.renderCodes = "pure"

# -- #########################################
# # Introduction
# In this chapter, we try to focus on concepts and theories, reading this chapter helps the reader understand the concepts and fundamentals but to turn these theories into practice, one must read the main chapter of each section which is more practical. Not all of units are needed to be defined by the programmer and most of them are generated by XUA. There are only a few units that require practical understanding, and there is a main chapter for each.  

# -- #########################################
# # XUA Server
# XUA generates three projects. XUA Server, Marshal Library, and Documentations. Among these projects, the server is the most important
# one which contains all the units that serve logics to the whole project. The role of Server is to be an interface between user and
# database which reads and modifies data, in this manner the server must check the permissions for read and write and serve proper
# access to data for all users.

# ## Universal Resources Pool
# A XUA Server contains a pool of resources that are available for use. These resources can be available universally, i.e., foreign
# parties can use resources, and internally, i.e., available for internal resources and units. The idea is similar to private and
# public features of a class, but a public feature is only accessible from other codes on the same project, while a universal resource
# is accessible from other projects, even on other machines other than where server project is stored. XUA resources are divided to [Files](#Resource_Files), [Services](#PHP_Service_Classes), [Supers](#Super_Types), [Entities](#Entities), and [Methods](#Methods).

# ### Super Types
# [(main chapter)](Supers.html)

# Super Types or simply Supers are actually parametric types.

# Let's talk about types first. One can think of a type as a set, for example the type `Integer` is actually the set $\mathbb{Z} = \{0, 1, -1, 2, -2, \dots \}$ and when we say that $42$ is of type `Integer`, this means that $42 \in \mathbb{Z}$, which is written $42 : \mathbb{Z}$ in XUA syntax. But there are some features that types usually have which sets don't. In XUA's definition of type, types have a characteristic function which defines the set, and also a marshal function and an unmarshal function that prepare the values for transmitting or storing. There is also another property for types, called `DatabaseType` which tells the database how to store a value of this type. So a type is actually a 4-tuple $T = (P, M, U, D)$ where predicate $P$ is the characteristic function, $M$ is the marshal function, $U$ is the unmarshal function, and $D$ is a string that defines the database type.

# As an example (that is not quite practical and efficient) let $T$ be the type of integers. We know $P(42)$ is true therefore we can say $42 : T$. It seems that $M$ must be $U^{-1}$ but it is not a necessity. Let's say that $M$ takes an integer and returns it's binary representation. therefore $M(42) = '101010'$. The $U$ must be the opposite so $U('101010') = 42$. but what is $U('42')$, the decimal representation in a string, can we say this is undefined and domain of $U$ only accepts binary strings? This is up to the programmer that either $U = M^{-1}$ or not and programmer must define both $M$ and $U$ functions separately. At last, if we use MySQL for database server, we can say $D$ is the string `VARCHAR(100)`. This is because the result of our marshal function is a string and XUA uses that to store data in database.  

# Now what is a Super Type? A super type is actually a function that takes some parameters and returns a type, a super type is an object a whole level above a type. Each super type eventually results in a PHP class extending a XUA abstract class called `\XUA\Type`. each instance of this class is a type, and the class constructor is the function that takes some parameters and creates a type. The parameters are then accessible as attributes. For example take a look at `Enum` that takes one parameter called `values`.
#    $genderType = new Enum([
#        'values' => ['male', 'female']
#    ]);

# The parameter `values` is set to array `['male', 'female']` and the variable `$genderType` is now a type that has the 4 discussed members.

# $P$, the first member, is called `accepts`.
#    var_dump($genderType->accepts('male')); \\ dumps true
# Since $'male' \in \{'male', 'female'\}$.

# $M$, the second member, is called `marshal`, and will return the index of the element in array `values`.
#    var_dump($genderType->marshal('male')); \\ dumps 0
#    var_dump($genderType->marshal('female')); \\ dumps 1

# $U$, the third member, is called `unmarshal`.
#    var_dump($genderType->unmarshal(1)); \\ dumps 'female'
# __Note__: The marshal and unmarshal functions of XUA's official Enum are both identity function, this is just an example.

# $D$, the fourth member, is called `databaseType`.
#    var_dump($genderType->databaseType()); \\ dumps 'INT'

# There is also another member of this type, that gives you the parameters given to it when constructed.
#    $genderType->parameters();
# Will return the following map.
#    [
#        'value' => ['male', 'female']
#    ]

# ### Entities
# [(main chapter)](Entities.html)

# XUA can be configured to communicate with a database server (usually MySQL), but the programmer needs to specify the database structure. To do so, XUA offers Entity Blocks, XUA will generate a PHP class extending a XUA abstract class called `\XUA\Entity` for each Entity Block the programmer creates. these Entity classes are in a one-to-one relationship with database tables. Each row of the table then, can be corresponded by an instance of the tableâ€™s corresponding class.

# In order to define an entity, the programmer needs to define a mapping called `Fields` that contains columns of entities as keys, and their types as values. Setting the `Fields` is mandatory, but there are some optional members an entity may have. One member is a list called `Indexes`, which defines the MySQL indexes, that would make select queries faster, or control unique values (Read more about MySQL indexes by googling). Another is the function called `Validation`, that checks if an entity instance (a row) is valid. For example assume we have two fields `country` and `city` in entity `User`, the validation function is responsible to check if the city is inside the country and avoid invalid data from storing. Therefore an entity is theoretically a triplet $E = (F, I, V)$, but you'll see that you can override entity methods, i.e., there are more to define on entity than just `Fields`, `Indexes`, and `Validation`.  

# ### Methods
# [(main chapter)](Methods.html)

# Methods are the main part of a XUA Project. A method is a very small unit that does a special job when called. One can think of methods as just functions but there are two differences. A method can be called from outside of the project, and can return multiple values.

# Methods are simply triplets $M = (Q, S, B)$. First member, `Request`, shown by $Q$, defines the structure of request that needs to be prepared and given to the method, and the second one, `Response`, shown by $S$, defines the structure of response that the method returns. The third member, `Body`, shown by $B$ is a piece of code that does all the function.

# ### PHP Service Classes
# [(main chapter)](Services.html)

# There are some data-types that are more than an entity or a super type. Some classes like `DateTime` are not in an equivalence relation with a database table, and are not possible to implement with XUA's super types, since the programmer may need methods like `addDays`, `format`, or `toJalali` from this data-type.

# Also there are some procedures that need to be implemented somewhere other than methods, for example checking if a file is an image.

# XUA satisfies this need by letting programmers write their own native PHP codes. Although the codes must be contained by classes, but the programmer is pretty mush free to do everything inside the classes. The XUA engine will copy these native codes to the resulting project as they are.

# ## Interfaces
# [(main chapter)](Interfaces.html)

# interfaces are where we define routes, and write the code that will execute when a user requests on a specific route, we usually avoid writing codes that include business logic, instead we just call a resource that is responsible for the route. Since we have a specific route called [URPI](#Universal_Resources_Pool_Interface_\(URPI\)) that handles all the direct requests for resources, writing a new interface is mostly useful for rendering a website, i.e., we define routes for pages the user visits, and ask a resource (a Method resource) to create an html page, and show the page created to user.

# ## Resource Files
# In almost any project, there are some files that are note codes or programs, these files can be anything, assets, user uploaded files, documents, etc. In XUA's terminology, we call any non-program file, a resource file. The resource files exist directly in the resulting project directory, and the programmer must mark the directories that contain resource files as resource directory in `config.json`. Read [Configurations article](Configurations.html) to see how it is done.

# ### Public Resource Files
# Resource files can be public, i.e., accessible by just going to the file's address. For example when user opens a web page in the browser, there are some assets, e.g., styles, fonts, images, etc. that browser fetches from the web server. These files must be marked as public.

# ### Private Resource Files
# In many projects, there are some files that are needed to be on the server, but are not public files. For example think of an _online book store_. There are many `.pdf` files on the server which the server sends them by email or shows them on web only if the user is authorized and payed for the file. These files must be marked as private.

# ## XUA Server Generated Units
# There are some units existing in the server project, that are completely generated by XUA engine and there is no need for a programmer to modify them, but it helps if the programmer knows how they work, and in some cases, the programmer may modify them in a way that is more suitable for the project.

# ### Universal Resources Pool Interface (URPI)
# Accessing resources on same project is as easy as it was before, one unit can just call a resource internally and there is no complexity. Although accessing a resource form other machines needs a protocol, the client needs to marshal the request in a data type which is available for transmitting on the network, then we need to unmarshal the request in a way that is meaningful for Universal Resource Pool, this is done by a predefined interface called URPI. The client tells URPI what resource is needed, URPI calls the resource, prepare the result for network transmitting, and sends the result back to client, where the result can be unmarshalled and used.

# __Note:__ The URPI is an interface, existing in the interfaces directory of the template project. The URPI is a xua source file, meaning it is not generated when building the project, it's generated only once, when making a new project from template. Therefore this unit is modifiable and even removable.

# ### Route Detection Unit
# The programmer can define [interfaces](#Interfaces) and set a route for each interface. When a user or client sends a request to the server, it's the job of RDU to detect which route (which interface) matches the requested URL. After the route is detected, XUA will call the interface with that specific route, and then the code inside that interface returns the desired response.

# __Note:__ RDU is generated each time the project is built. The modification of RDU is highly discouraged, but if one insists on, it's recommended to change it in _XUA code generator_ source files, not the resulting project, since it'll get replaced with the default one each time the project is built. 

# ### XUA Exception Handler
# After the interface returned the response, it's not prepared to show to the user yet. Immediately after interface code execution, the result goes to the XEH, any uncaught exception, fatal error, warning, etc. gets caught here, and a default error page is shown to user in order to avoid inside codes and data leak, as well as making the website more user friendly.

# It is possible to modify the way XUA catches exceptions by modifying a special service called `ExceptionService`. For example you may want to make it possible for developers and programmers of the project to see the exact error while users must just see a simple error page. Or you may want to show an error message in json instead of showing an html page (which is already done for [URPI](#Universal_Resources_Pool_Interface_\(URPI\))). In this cases or other similar cases, you should modify `ExceptionService` and check if the request is sent by a developer, for example by checking a special header. Read [ExceptionService](PredefinedServices.html#ExceptionService) for more practical information.

# ### Template Engine
# The result that RDU or XEH return is an instance of class `\XUA\Template`. In order to send it as a response, XUA needs to render the instance. This is done by the last unit, TE.

# XUA uses Twig templates with the class `\XUA\TwigTemplate` by default but it's possible to override it. You just have to extend the abstract class `\XUA\Template` with another template engine like `\XUA\MyOwnTemplate`, and use instances of this class as return values of interfaces and XEH.

# -- #########################################
# # Marshal Library

# The _Marshal Library_ is a client library can be built in several front-end languages. The library helps the front-end developers to access resources from Universal Resources Pool. For example if there is a method in the pool called `Method\Post\Get`, the front-end developer can call it using the following code in Dart.
#    result = Marshal.Method.Post.Get(arguments);

# The marshal library sends a request to the server saying we need to execute the method `Method\Post\Get`, along with marshaled `arguments`, the URPI then, unmarshals the `arguments`, calls the method, gets response, marshals it, and send it back to the client, the marshal library fetches it, unmarshals it, and returns the structured response, which then will be stored in `result`.

# ## Virtual Resource Pool
# The Virtual Resource Pool is a set of methods and entities, twins of the ones in server, that just contain a server call and nothing more.

# ### Entity Interfaces
# For each entity on the server project, a twin entity exists inside VRP, but with hollow methods. Each method only contains an HTTP request that tells the server to execute it's twin, the result is fetched from server and is returned.

# ### Method Interfaces
# For each method on the server project, a twin method exists inside VRP, but with hollow body. The body only contains an HTTP request that tells the server to execute it's twin, the result is fetched from server and is returned.

# ## Local Service Classes
# [(main chapter)](Services.html)

# [PHP Service Classes](#PHP_Service_Classes) discussed above are classes that programmers may use to instantiate objects from. These objects can be used in universal resources, for example a method may return an instance of a service class. XUA marshals the result and sends it to the _Marshal Library_ where it should be unmarshalled. But how we're gonna represent the object there? Assume we have a method called `getNow`, and the method responses the variable `now`, an instance of `DateTimeService`. Then in the Dart project we want to get the Jalali representation of the `DateTimeService` using the method `formatJalali`. This is not something we ask the server to do for us. We should be able to execute the method in the client side. Therefore, if we want to use some methods of some service classes in the client-side, we should rewrite the class in native language of the client-side. The programmer is able to write native codes for the client, and the codes are copied to the _Marshal Library_ when building.

# ## Marshal Library Generated Units
# Just as the server project, there are some units existing in the marshal library, that are completely generated by XUA engine and there is no need for a programmer to modify them, but it helps if the programmer knows how they work, and in some cases, the programmer may modify them in a way that is more suitable for the project.

# ### Marshal/Unmarshal Unit
# The unit that the library derived it's name from. This unit is responsible to marshal request data and unmarshal the response. The unit is affected by supers definitions, but is not directly programmable.

# ### Http Connection Unit
# This is a very technical unit where requests are sent to the server, and responses are fetched. This unit is also able to modify requests and responses, for example adding user token, api key, etc. to the request. This unit is possible to modify. The programmer must modify a predefined service called `HttpConnectionService`. Read [HttpConnectionService](PredefinedServices.html#HttpConnectionService) for more practical information.

# -- #########################################
# # Documentations
# [(main chapter)](Documentations.html)

# XUA is capable of generating a documentation for the project. Currently, the documentation is available in html and latex formats. XUA engine uses comments inside project source files to generate the docs. The current documentation that you're reading is a documentation generated by xua, and all these texts are just comments inside source files.

# The documentations are file-to-file, meaning that for each source file, there exists a `.html` or `.tex` file and vice versa.

# ## Service Classes Documentations
# Service classes are the files labeled as services in `config.json`, and are only project source file without `.xua` extension. For each of these files, XUA engine generates a documentation file consisting of the comments.

# ## Super Types Documentations
# Other than including the comments in the documentation, XUA can automatically generate a table of super parameters, with their types, default values, and description. The description of a parameter is the comment that comes immediately after the parameter definition, if no comment is found, the description is set to `-`. XUA can also sectionize different parts of a super, like validation, marshal, unmarshal, etc. and shows comments of each one in the related section. There are also some other minor automated functions that XUA is capable of.

# ## Entities Documentations
# Other than including the comments in the documentation, XUA can automatically generate a table of entity fields, with their types, default values, description, etc. The description of a field is the comment that comes immediately after the field definition, if no comment is found, the description is set to `-`. XUA can also sectionize different parts of an entity, and some other automated functions.

# ## Entities Graph
# Almost any project has some related entities, for example we may have an entity called `User` that has a field called `birthPlace` that comes from another Entity called `City`, and we may have another entity called `Restaurant` that has a field called `costumers` which comes from `User`, and a field called `city` that comes from `City`, and there would be many other entities with relations, these relations can be one-to-one, one-to-many, many-to-many, etc. Most of these complicated projects have a graph of entities as vertices, showing the relations by edges. XUA is capable of drawing this graph and modify it whenever an entity is modified. 

# ## Methods Documentations
# Other than including the comments in the documentation, XUA can automatically generate a table of request parameter, and a table of response parameters, with their types, default values, description, etc. The description of a field is the comment that comes immediately after the parameter definition, if no comment is found, the description is set to `-`. XUA can also sectionize different parts of a method, and some other automated functions.

# ## Book
# Book is actually the name we call a `.xua` file, or a set of `.xua` files, when the file contains nothing, i.e., there is no super, method, or entity block. The file is empty of codes, but it can be full of comments, just like the one you're reading currently.

# -- #########################################
# # Foreign Units
# There are a set of units that are out of our control, they just work as they are, but they _are_ important to us since we want to communicate with them.

# ## System Resources
# System resource are usually procedures that are not written in PHP. For example chron-jobs, shell commands, Redis queues, foreign language codes, etc. But we may want to use these resources in our project. This can be done through a service.

# For example assume we have a code contest website, and want to compile and run some tests on uploaded codes. We may have a foreign judge project that does this for us, we just need to call it. We can write a service called `callJudgeService` and use it in a method. or if we want to manage a queue, we can write a service called `QueuesService` and call it like
#    QueuesService::addToQueue(QueuesService::QUEUE_WAITING_TO_JUDGE_CODES, $uploadedCode)

# ## Libraries
# There can be some PHP libraries that we are not wishing to rewrite, for example generating a QR Code, reading an excel file, etc. We can have these codes available and write a service to call these for us. It's important to mark libraries as resource files in `config.json`, or they will be deleted when cleaning the project.

# ## 3rd Party Apps
# Just similar to System Resources, and Libraries, we can write services and interfaces to communicate with 3rd Party Apps.

# ## Database and Cache Servers
# One of the most important features of any server project is to communicate with a database server, entities are configured to do so. But it's also possible to configure entities to connect to a cache server instead, the cache server then communicates with the database if the data was not available.

# ## Web Browser
# Web browser is the interface that user communicates with, if the project is not just a back-end project, and contains a website, then web browser is the application that communicates with the server project, which may ask for different URLs on the server that will get handled by interfaces.

# ## Native Client Codes
# Client Codes are the codes written by front-end developers that is a user inteface for the project. These code may not communicate with the server directly, instead, the Marshal Library is called to communicate with the server.
